#!/usr/bin/env python
# -*- coding=utf-8 -*-

import threading, Queue, sys, traceback, time, threadpool, re, subprocess, logging, os
import vistek_psia, vistek_hikvision, vistek_onvif
#process_count = 0

if not os.path.exists("log"):
    os.mkdir("log")
log_file = "log\{0}.log".format(__name__)
log_level = logging.DEBUG

logger = logging.getLogger(__name__)
handler = logging.handlers.TimedRotatingFileHandler(log_file, when="D", interval=1)
formatter = logging.Formatter(
    "[%(asctime)s] [%(levelname)s] [%(name)s] [%(filename)s:%(funcName)s:%(lineno)s]  %(message)s")

handler.setFormatter(formatter)
logger.addHandler(handler)
logger.setLevel(log_level)
class Worker(threading.Thread):
    worker_count = 0
    def __init__( self, timeout = 0, **kwds):
        threading.Thread.__init__( self, **kwds )
        self.id = Worker.worker_count
        self._id = str(threading.currentThread())
        Worker.worker_count += 1
        self.setDaemon( True )
        self.workQueue = Queue.Queue()
        self.resultQueue = Queue.Queue()
        self.timeout = timeout
        self._is_stoped = False
        self.start()

    def run( self ):
        ''' the get-some-work, do-some-work main loop of worker threads '''
        while not self._is_stoped:
            try:
                callable, args, kwds = self.workQueue.get(timeout=self.timeout)
                res = callable(*args, **kwds)
                if res:
                    self.resultQueue.put( res )
                print "worker[%2d]: %s" % (self.id, str(res) )
            except Queue.Empty:
                break
            except :
                print 'worker[%2d]' % self.id, sys.exc_info()[:2]

    def stop(self):
        self._is_stoped = True

    def result_queue_size(self):
        return self.resultQueue.qsize()

    def result_queue_empty(self):
        return self.resultQueue.empty()

    def add_task(self, callable, *args, **kwds):
        self.workQueue.put((callable, args, kwds))

    def get_result(self, *args, **kwds):
        return self.resultQueue.get(*args, **kwds)

def is_device_on_line(device):
    ping_cmd = "ping -n 2 {0}".format(str(device.IP))
    ret = os.system(ping_cmd)
    if ret:
        return False
    else:
    		logger.info("device is on line but can't find process, device:", device)
        return True
    p = subprocess.Popen([ping_cmd],
                        stdin = subprocess.PIPE,
                        stdout = subprocess.PIPE,
                        stderr = subprocess.PIPE,
                        shell = True)
    out = p.stdout.read()
    regex = re.compile("time=\d*", re.IGNORECASE | re.MULTILINE)
    if len(regex.findall(out)) > 0:
        logger.info("device is on line but can't find process, device:", device)
        return True
    else:
        return False

def is_device_can_process(device):
    if 0 == device.ProtocolFlag:
        return False
    else:
        return True

def try_device_process(device):
    """
    the device can use the current package to process.
    :device
    :return tuple (is_can_process, update device info)
    """

    can_proc_device_list = []
    out_data = vistek_hikvision.try_process_device(device)
    if out_data and out_data[1]:
        device.ProtocolFlag = out_data[2]
        can_proc_device_list.append(device)
    out_data = vistek_onvif.try_process_device(device)
    if out_data and out_data[1]:
        device.ProtocolFlag = out_data[2]
        can_proc_device_list.append(device)
    out_data = vistek_psia.try_process_device(device)
    if out_data and out_data[1]:
        device.ProtocolFlag = out_data[2]
        can_proc_device_list.append(device)
    if 0 < len(can_proc_device_list):
        logger.info("try process success device list:", can_proc_device_list)
    #if device.DeviceID == "37262ee8-1970-4f10-9948-21f30160936b":
    #    device.ProtocolFlag = 1
    #    can_proc_device_list.append(device)
    return can_proc_device_list


    ##################################################################
    #global process_count
    # try:
    #     print("time:{0} device_process begin thrd:{1}".format(time.asctime(time.localtime(time.time())), threading.currentThread()))
    #     do_proc_device_worker = Worker(timeout=10)
    #     do_proc_device_worker.add_task(vistek_onvif.try_process_device, device)
    #     do_proc_device_worker.add_task(vistek_psia.try_process_device, device)
    #     do_proc_device_worker.add_task(vistek_hikvision.try_process_device, device)
    #     if not do_proc_device_worker.isAlive():
    #          do_proc_device_worker.start()
    #     do_proc_device_worker.join()
    #     #worker_pool = threadpool.ThreadPool(3)
    #     #worker_req_lists = []
    #     #worker_req_lists.extend(threadpool.makeRequests(vistek_hikvision.try_device_process, [((device,), {})]))
    #     #worker_req_lists.extend(threadpool.makeRequests(vistek_onvif.try_process_device, [((device,), {})]))
    #     #worker_req_lists.extend(threadpool.makeRequests(vistek_psia.try_process_device, [((device,), {})]))
    #     #threadpool.WorkerThread()
    #     #for req in worker_req_lists:
    #     #    worker_pool.putRequest(req)
    #     #worker_pool.wait()
    #     print("time:{0} device_process success, thrd:{1} result count:{2}".format(time.asctime(time.localtime(time.time())), threading.currentThread(), do_proc_device_worker.result_queue_size()))
    #     #return can_proc_device_list
    # except:
    #     traceback.print_exc()
    # finally:
    #     do_proc_device_worker.stop()
    #     do_proc_device_worker.join(timeout=10)
    #
    # while not do_proc_device_worker.result_queue_empty():
    #     out_data = do_proc_device_worker.get_result()
    #     if out_data[1]:
    #         break

