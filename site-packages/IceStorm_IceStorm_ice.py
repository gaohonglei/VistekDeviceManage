# **********************************************************************
#
# Copyright (c) 2003-2015 ZeroC, Inc. All rights reserved.
#
# This copy of Ice is licensed to you under the terms described in the
# ICE_LICENSE file included in this distribution.
#
# **********************************************************************
#
# Ice version 3.6.1
#
# <auto-generated>
#
# Generated from file `IceStorm.ice'
#
# Warning: do not edit this file.
#
# </auto-generated>
#

import Ice, IcePy
import Ice_Identity_ice
import Ice_SliceChecksumDict_ice
import IceStorm_Metrics_ice

# Included module Ice
_M_Ice = Ice.openModule('Ice')

# Included module IceMX
_M_IceMX = Ice.openModule('IceMX')

# Start of module IceStorm
_M_IceStorm = Ice.openModule('IceStorm')
__name__ = 'IceStorm'
_M_IceStorm.__doc__ = '''A messaging service with support for federation. In contrast to
most other messaging or event services, IceStorm supports typed
events, meaning that broadcasting a message over a federation is as
easy as invoking a method on an interface.'''

if 'Topic' not in _M_IceStorm.__dict__:
    _M_IceStorm._t_Topic = IcePy.declareClass('::IceStorm::Topic')
    _M_IceStorm._t_TopicPrx = IcePy.declareProxy('::IceStorm::Topic')

if 'LinkInfo' not in _M_IceStorm.__dict__:
    _M_IceStorm.LinkInfo = Ice.createTempClass()
    class LinkInfo(object):
        '''Information on the topic links.'''
        def __init__(self, theTopic=None, name='', cost=0):
            self.theTopic = theTopic
            self.name = name
            self.cost = cost

        def __eq__(self, other):
            if other is None:
                return False
            elif not isinstance(other, _M_IceStorm.LinkInfo):
                return NotImplemented
            else:
                if self.theTopic != other.theTopic:
                    return False
                if self.name != other.name:
                    return False
                if self.cost != other.cost:
                    return False
                return True

        def __ne__(self, other):
            return not self.__eq__(other)

        def __str__(self):
            return IcePy.stringify(self, _M_IceStorm._t_LinkInfo)

        __repr__ = __str__

    _M_IceStorm._t_LinkInfo = IcePy.defineStruct('::IceStorm::LinkInfo', LinkInfo, (), (
        ('theTopic', (), _M_IceStorm._t_TopicPrx),
        ('name', (), IcePy._t_string),
        ('cost', (), IcePy._t_int)
    ))

    _M_IceStorm.LinkInfo = LinkInfo
    del LinkInfo

if '_t_LinkInfoSeq' not in _M_IceStorm.__dict__:
    _M_IceStorm._t_LinkInfoSeq = IcePy.defineSequence('::IceStorm::LinkInfoSeq', (), _M_IceStorm._t_LinkInfo)

if '_t_QoS' not in _M_IceStorm.__dict__:
    _M_IceStorm._t_QoS = IcePy.defineDictionary('::IceStorm::QoS', (), IcePy._t_string, IcePy._t_string)

if 'LinkExists' not in _M_IceStorm.__dict__:
    _M_IceStorm.LinkExists = Ice.createTempClass()
    class LinkExists(Ice.UserException):
        '''This exception indicates that an attempt was made to create a link
that already exists.'''
        def __init__(self, name=''):
            self.name = name

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_name = 'IceStorm::LinkExists'

    _M_IceStorm._t_LinkExists = IcePy.defineException('::IceStorm::LinkExists', LinkExists, (), False, None, (('name', (), IcePy._t_string, False, 0),))
    LinkExists._ice_type = _M_IceStorm._t_LinkExists

    _M_IceStorm.LinkExists = LinkExists
    del LinkExists

if 'NoSuchLink' not in _M_IceStorm.__dict__:
    _M_IceStorm.NoSuchLink = Ice.createTempClass()
    class NoSuchLink(Ice.UserException):
        '''This exception indicates that an attempt was made to remove a
link that does not exist.'''
        def __init__(self, name=''):
            self.name = name

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_name = 'IceStorm::NoSuchLink'

    _M_IceStorm._t_NoSuchLink = IcePy.defineException('::IceStorm::NoSuchLink', NoSuchLink, (), False, None, (('name', (), IcePy._t_string, False, 0),))
    NoSuchLink._ice_type = _M_IceStorm._t_NoSuchLink

    _M_IceStorm.NoSuchLink = NoSuchLink
    del NoSuchLink

if 'AlreadySubscribed' not in _M_IceStorm.__dict__:
    _M_IceStorm.AlreadySubscribed = Ice.createTempClass()
    class AlreadySubscribed(Ice.UserException):
        '''This exception indicates that an attempt was made to subscribe
a proxy for which a subscription already exists.'''
        def __init__(self):
            pass

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_name = 'IceStorm::AlreadySubscribed'

    _M_IceStorm._t_AlreadySubscribed = IcePy.defineException('::IceStorm::AlreadySubscribed', AlreadySubscribed, (), False, None, ())
    AlreadySubscribed._ice_type = _M_IceStorm._t_AlreadySubscribed

    _M_IceStorm.AlreadySubscribed = AlreadySubscribed
    del AlreadySubscribed

if 'InvalidSubscriber' not in _M_IceStorm.__dict__:
    _M_IceStorm.InvalidSubscriber = Ice.createTempClass()
    class InvalidSubscriber(Ice.UserException):
        '''This exception indicates that an attempt was made to subscribe
a proxy that is null.'''
        def __init__(self, reason=''):
            self.reason = reason

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_name = 'IceStorm::InvalidSubscriber'

    _M_IceStorm._t_InvalidSubscriber = IcePy.defineException('::IceStorm::InvalidSubscriber', InvalidSubscriber, (), False, None, (('reason', (), IcePy._t_string, False, 0),))
    InvalidSubscriber._ice_type = _M_IceStorm._t_InvalidSubscriber

    _M_IceStorm.InvalidSubscriber = InvalidSubscriber
    del InvalidSubscriber

if 'BadQoS' not in _M_IceStorm.__dict__:
    _M_IceStorm.BadQoS = Ice.createTempClass()
    class BadQoS(Ice.UserException):
        '''This exception indicates that a subscription failed due to an
invalid QoS.'''
        def __init__(self, reason=''):
            self.reason = reason

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_name = 'IceStorm::BadQoS'

    _M_IceStorm._t_BadQoS = IcePy.defineException('::IceStorm::BadQoS', BadQoS, (), False, None, (('reason', (), IcePy._t_string, False, 0),))
    BadQoS._ice_type = _M_IceStorm._t_BadQoS

    _M_IceStorm.BadQoS = BadQoS
    del BadQoS

if 'Topic' not in _M_IceStorm.__dict__:
    _M_IceStorm.Topic = Ice.createTempClass()
    class Topic(Ice.Object):
        '''Publishers publish information on a particular topic. A topic
logically represents a type.'''
        def __init__(self):
            if Ice.getType(self) == _M_IceStorm.Topic:
                raise RuntimeError('IceStorm.Topic is an abstract class')

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::IceStorm::Topic')

        def ice_id(self, current=None):
            return '::IceStorm::Topic'

        def ice_staticId():
            return '::IceStorm::Topic'
        ice_staticId = staticmethod(ice_staticId)

        def getName(self, current=None):
            '''Get the name of this topic.

Returns:
    The name of the topic.'''
            pass

        def getPublisher(self, current=None):
            '''Get a proxy to a publisher object for this topic. To publish
data to a topic, the publisher calls getPublisher and then
casts to the topic type. An unchecked cast must be used on this
proxy. If a replicated IceStorm deployment is used this call
may return a replicated proxy.

Returns:
    A proxy to publish data on this topic.'''
            pass

        def getNonReplicatedPublisher(self, current=None):
            '''Get a non-replicated proxy to a publisher object for this
topic. To publish data to a topic, the publisher calls
getPublisher and then casts to the topic type. An unchecked
cast must be used on this proxy.

Returns:
    A proxy to publish data on this topic.'''
            pass

        def subscribeAndGetPublisher(self, theQoS, subscriber, current=None):
            '''Subscribe with the given qos to this topic.  A
per-subscriber publisher object is returned.

Arguments:
    theQoS The quality of service parameters for this
subscription.

    subscriber The subscriber's proxy.

Returns:
    The per-subscriber publisher object.

Exceptions:
    AlreadySubscribed Raised if the subscriber object is
already subscribed.

    NullSubscriber Raised if the subscriber object is null.

    BadQoS Raised if the requested quality of service
is unavailable or invalid.'''
            pass

        def unsubscribe(self, subscriber, current=None):
            '''Unsubscribe the given subscriber.

Arguments:
    subscriber The proxy of an existing subscriber.'''
            pass

        def link(self, linkTo, cost, current=None):
            '''Create a link to the given topic. All events originating
on this topic will also be sent to linkTo.

Arguments:
    linkTo The topic to link to.

    cost The cost to the linked topic.

Exceptions:
    LinkExists Raised if a link to the same topic already
exists.'''
            pass

        def unlink(self, linkTo, current=None):
            '''Destroy the link from this topic to the given topic linkTo.

Arguments:
    linkTo The topic to destroy the link to.

Exceptions:
    NoSuchLink Raised if a link to the topic does not exist.'''
            pass

        def getLinkInfoSeq(self, current=None):
            '''Retrieve information on the current links.

Returns:
    A sequence of LinkInfo objects.'''
            pass

        def getSubscribers(self, current=None):
            '''Retrieve the list of subscribers for this topic.

Returns:
    The sequence of Ice identities for the subscriber objects.'''
            pass

        def destroy(self, current=None):
            '''Destroy the topic.'''
            pass

        def __str__(self):
            return IcePy.stringify(self, _M_IceStorm._t_Topic)

        __repr__ = __str__

    _M_IceStorm.TopicPrx = Ice.createTempClass()
    class TopicPrx(Ice.ObjectPrx):

        '''Get the name of this topic.

Returns:
    The name of the topic.'''
        def getName(self, _ctx=None):
            return _M_IceStorm.Topic._op_getName.invoke(self, ((), _ctx))

        '''Get the name of this topic.

Returns:
    The name of the topic.'''
        def begin_getName(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_IceStorm.Topic._op_getName.begin(self, ((), _response, _ex, _sent, _ctx))

        '''Get the name of this topic.

Returns:
    The name of the topic.'''
        def end_getName(self, _r):
            return _M_IceStorm.Topic._op_getName.end(self, _r)

        '''Get a proxy to a publisher object for this topic. To publish
data to a topic, the publisher calls getPublisher and then
casts to the topic type. An unchecked cast must be used on this
proxy. If a replicated IceStorm deployment is used this call
may return a replicated proxy.

Returns:
    A proxy to publish data on this topic.'''
        def getPublisher(self, _ctx=None):
            return _M_IceStorm.Topic._op_getPublisher.invoke(self, ((), _ctx))

        '''Get a proxy to a publisher object for this topic. To publish
data to a topic, the publisher calls getPublisher and then
casts to the topic type. An unchecked cast must be used on this
proxy. If a replicated IceStorm deployment is used this call
may return a replicated proxy.

Returns:
    A proxy to publish data on this topic.'''
        def begin_getPublisher(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_IceStorm.Topic._op_getPublisher.begin(self, ((), _response, _ex, _sent, _ctx))

        '''Get a proxy to a publisher object for this topic. To publish
data to a topic, the publisher calls getPublisher and then
casts to the topic type. An unchecked cast must be used on this
proxy. If a replicated IceStorm deployment is used this call
may return a replicated proxy.

Returns:
    A proxy to publish data on this topic.'''
        def end_getPublisher(self, _r):
            return _M_IceStorm.Topic._op_getPublisher.end(self, _r)

        '''Get a non-replicated proxy to a publisher object for this
topic. To publish data to a topic, the publisher calls
getPublisher and then casts to the topic type. An unchecked
cast must be used on this proxy.

Returns:
    A proxy to publish data on this topic.'''
        def getNonReplicatedPublisher(self, _ctx=None):
            return _M_IceStorm.Topic._op_getNonReplicatedPublisher.invoke(self, ((), _ctx))

        '''Get a non-replicated proxy to a publisher object for this
topic. To publish data to a topic, the publisher calls
getPublisher and then casts to the topic type. An unchecked
cast must be used on this proxy.

Returns:
    A proxy to publish data on this topic.'''
        def begin_getNonReplicatedPublisher(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_IceStorm.Topic._op_getNonReplicatedPublisher.begin(self, ((), _response, _ex, _sent, _ctx))

        '''Get a non-replicated proxy to a publisher object for this
topic. To publish data to a topic, the publisher calls
getPublisher and then casts to the topic type. An unchecked
cast must be used on this proxy.

Returns:
    A proxy to publish data on this topic.'''
        def end_getNonReplicatedPublisher(self, _r):
            return _M_IceStorm.Topic._op_getNonReplicatedPublisher.end(self, _r)

        '''Subscribe with the given qos to this topic.  A
per-subscriber publisher object is returned.

Arguments:
    theQoS The quality of service parameters for this
subscription.

    subscriber The subscriber's proxy.

Returns:
    The per-subscriber publisher object.

Exceptions:
    AlreadySubscribed Raised if the subscriber object is
already subscribed.

    NullSubscriber Raised if the subscriber object is null.

    BadQoS Raised if the requested quality of service
is unavailable or invalid.'''
        def subscribeAndGetPublisher(self, theQoS, subscriber, _ctx=None):
            return _M_IceStorm.Topic._op_subscribeAndGetPublisher.invoke(self, ((theQoS, subscriber), _ctx))

        '''Subscribe with the given qos to this topic.  A
per-subscriber publisher object is returned.

Arguments:
    theQoS The quality of service parameters for this
subscription.

    subscriber The subscriber's proxy.

Returns:
    The per-subscriber publisher object.

Exceptions:
    AlreadySubscribed Raised if the subscriber object is
already subscribed.

    NullSubscriber Raised if the subscriber object is null.

    BadQoS Raised if the requested quality of service
is unavailable or invalid.'''
        def begin_subscribeAndGetPublisher(self, theQoS, subscriber, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_IceStorm.Topic._op_subscribeAndGetPublisher.begin(self, ((theQoS, subscriber), _response, _ex, _sent, _ctx))

        '''Subscribe with the given qos to this topic.  A
per-subscriber publisher object is returned.

Arguments:
    theQoS The quality of service parameters for this
subscription.

    subscriber The subscriber's proxy.

Returns:
    The per-subscriber publisher object.

Exceptions:
    AlreadySubscribed Raised if the subscriber object is
already subscribed.

    NullSubscriber Raised if the subscriber object is null.

    BadQoS Raised if the requested quality of service
is unavailable or invalid.'''
        def end_subscribeAndGetPublisher(self, _r):
            return _M_IceStorm.Topic._op_subscribeAndGetPublisher.end(self, _r)

        '''Unsubscribe the given subscriber.

Arguments:
    subscriber The proxy of an existing subscriber.'''
        def unsubscribe(self, subscriber, _ctx=None):
            return _M_IceStorm.Topic._op_unsubscribe.invoke(self, ((subscriber, ), _ctx))

        '''Unsubscribe the given subscriber.

Arguments:
    subscriber The proxy of an existing subscriber.'''
        def begin_unsubscribe(self, subscriber, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_IceStorm.Topic._op_unsubscribe.begin(self, ((subscriber, ), _response, _ex, _sent, _ctx))

        '''Unsubscribe the given subscriber.

Arguments:
    subscriber The proxy of an existing subscriber.'''
        def end_unsubscribe(self, _r):
            return _M_IceStorm.Topic._op_unsubscribe.end(self, _r)

        '''Create a link to the given topic. All events originating
on this topic will also be sent to linkTo.

Arguments:
    linkTo The topic to link to.

    cost The cost to the linked topic.

Exceptions:
    LinkExists Raised if a link to the same topic already
exists.'''
        def link(self, linkTo, cost, _ctx=None):
            return _M_IceStorm.Topic._op_link.invoke(self, ((linkTo, cost), _ctx))

        '''Create a link to the given topic. All events originating
on this topic will also be sent to linkTo.

Arguments:
    linkTo The topic to link to.

    cost The cost to the linked topic.

Exceptions:
    LinkExists Raised if a link to the same topic already
exists.'''
        def begin_link(self, linkTo, cost, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_IceStorm.Topic._op_link.begin(self, ((linkTo, cost), _response, _ex, _sent, _ctx))

        '''Create a link to the given topic. All events originating
on this topic will also be sent to linkTo.

Arguments:
    linkTo The topic to link to.

    cost The cost to the linked topic.

Exceptions:
    LinkExists Raised if a link to the same topic already
exists.'''
        def end_link(self, _r):
            return _M_IceStorm.Topic._op_link.end(self, _r)

        '''Destroy the link from this topic to the given topic linkTo.

Arguments:
    linkTo The topic to destroy the link to.

Exceptions:
    NoSuchLink Raised if a link to the topic does not exist.'''
        def unlink(self, linkTo, _ctx=None):
            return _M_IceStorm.Topic._op_unlink.invoke(self, ((linkTo, ), _ctx))

        '''Destroy the link from this topic to the given topic linkTo.

Arguments:
    linkTo The topic to destroy the link to.

Exceptions:
    NoSuchLink Raised if a link to the topic does not exist.'''
        def begin_unlink(self, linkTo, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_IceStorm.Topic._op_unlink.begin(self, ((linkTo, ), _response, _ex, _sent, _ctx))

        '''Destroy the link from this topic to the given topic linkTo.

Arguments:
    linkTo The topic to destroy the link to.

Exceptions:
    NoSuchLink Raised if a link to the topic does not exist.'''
        def end_unlink(self, _r):
            return _M_IceStorm.Topic._op_unlink.end(self, _r)

        '''Retrieve information on the current links.

Returns:
    A sequence of LinkInfo objects.'''
        def getLinkInfoSeq(self, _ctx=None):
            return _M_IceStorm.Topic._op_getLinkInfoSeq.invoke(self, ((), _ctx))

        '''Retrieve information on the current links.

Returns:
    A sequence of LinkInfo objects.'''
        def begin_getLinkInfoSeq(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_IceStorm.Topic._op_getLinkInfoSeq.begin(self, ((), _response, _ex, _sent, _ctx))

        '''Retrieve information on the current links.

Returns:
    A sequence of LinkInfo objects.'''
        def end_getLinkInfoSeq(self, _r):
            return _M_IceStorm.Topic._op_getLinkInfoSeq.end(self, _r)

        '''Retrieve the list of subscribers for this topic.

Returns:
    The sequence of Ice identities for the subscriber objects.'''
        def getSubscribers(self, _ctx=None):
            return _M_IceStorm.Topic._op_getSubscribers.invoke(self, ((), _ctx))

        '''Retrieve the list of subscribers for this topic.

Returns:
    The sequence of Ice identities for the subscriber objects.'''
        def begin_getSubscribers(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_IceStorm.Topic._op_getSubscribers.begin(self, ((), _response, _ex, _sent, _ctx))

        '''Retrieve the list of subscribers for this topic.

Returns:
    The sequence of Ice identities for the subscriber objects.'''
        def end_getSubscribers(self, _r):
            return _M_IceStorm.Topic._op_getSubscribers.end(self, _r)

        '''Destroy the topic.'''
        def destroy(self, _ctx=None):
            return _M_IceStorm.Topic._op_destroy.invoke(self, ((), _ctx))

        '''Destroy the topic.'''
        def begin_destroy(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_IceStorm.Topic._op_destroy.begin(self, ((), _response, _ex, _sent, _ctx))

        '''Destroy the topic.'''
        def end_destroy(self, _r):
            return _M_IceStorm.Topic._op_destroy.end(self, _r)

        def checkedCast(proxy, facetOrCtx=None, _ctx=None):
            return _M_IceStorm.TopicPrx.ice_checkedCast(proxy, '::IceStorm::Topic', facetOrCtx, _ctx)
        checkedCast = staticmethod(checkedCast)

        def uncheckedCast(proxy, facet=None):
            return _M_IceStorm.TopicPrx.ice_uncheckedCast(proxy, facet)
        uncheckedCast = staticmethod(uncheckedCast)

        def ice_staticId():
            return '::IceStorm::Topic'
        ice_staticId = staticmethod(ice_staticId)

    _M_IceStorm._t_TopicPrx = IcePy.defineProxy('::IceStorm::Topic', TopicPrx)

    _M_IceStorm._t_Topic = IcePy.defineClass('::IceStorm::Topic', Topic, -1, (), True, False, None, (), ())
    Topic._ice_type = _M_IceStorm._t_Topic

    Topic._op_getName = IcePy.Operation('getName', Ice.OperationMode.Idempotent, Ice.OperationMode.Nonmutating, False, None, (), (), (), ((), IcePy._t_string, False, 0), ())
    Topic._op_getPublisher = IcePy.Operation('getPublisher', Ice.OperationMode.Idempotent, Ice.OperationMode.Nonmutating, False, None, (), (), (), ((), IcePy._t_ObjectPrx, False, 0), ())
    Topic._op_getNonReplicatedPublisher = IcePy.Operation('getNonReplicatedPublisher', Ice.OperationMode.Idempotent, Ice.OperationMode.Nonmutating, False, None, (), (), (), ((), IcePy._t_ObjectPrx, False, 0), ())
    Topic._op_subscribeAndGetPublisher = IcePy.Operation('subscribeAndGetPublisher', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_IceStorm._t_QoS, False, 0), ((), IcePy._t_ObjectPrx, False, 0)), (), ((), IcePy._t_ObjectPrx, False, 0), (_M_IceStorm._t_AlreadySubscribed, _M_IceStorm._t_InvalidSubscriber, _M_IceStorm._t_BadQoS))
    Topic._op_unsubscribe = IcePy.Operation('unsubscribe', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (((), IcePy._t_ObjectPrx, False, 0),), (), None, ())
    Topic._op_link = IcePy.Operation('link', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_IceStorm._t_TopicPrx, False, 0), ((), IcePy._t_int, False, 0)), (), None, (_M_IceStorm._t_LinkExists,))
    Topic._op_unlink = IcePy.Operation('unlink', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_IceStorm._t_TopicPrx, False, 0),), (), None, (_M_IceStorm._t_NoSuchLink,))
    Topic._op_getLinkInfoSeq = IcePy.Operation('getLinkInfoSeq', Ice.OperationMode.Idempotent, Ice.OperationMode.Nonmutating, False, None, (), (), (), ((), _M_IceStorm._t_LinkInfoSeq, False, 0), ())
    Topic._op_getSubscribers = IcePy.Operation('getSubscribers', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), ((), _M_Ice._t_IdentitySeq, False, 0), ())
    Topic._op_destroy = IcePy.Operation('destroy', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), None, ())

    _M_IceStorm.Topic = Topic
    del Topic

    _M_IceStorm.TopicPrx = TopicPrx
    del TopicPrx

if '_t_TopicDict' not in _M_IceStorm.__dict__:
    _M_IceStorm._t_TopicDict = IcePy.defineDictionary('::IceStorm::TopicDict', (), IcePy._t_string, _M_IceStorm._t_TopicPrx)

if 'TopicExists' not in _M_IceStorm.__dict__:
    _M_IceStorm.TopicExists = Ice.createTempClass()
    class TopicExists(Ice.UserException):
        '''This exception indicates that an attempt was made to create a topic
that already exists.'''
        def __init__(self, name=''):
            self.name = name

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_name = 'IceStorm::TopicExists'

    _M_IceStorm._t_TopicExists = IcePy.defineException('::IceStorm::TopicExists', TopicExists, (), False, None, (('name', (), IcePy._t_string, False, 0),))
    TopicExists._ice_type = _M_IceStorm._t_TopicExists

    _M_IceStorm.TopicExists = TopicExists
    del TopicExists

if 'NoSuchTopic' not in _M_IceStorm.__dict__:
    _M_IceStorm.NoSuchTopic = Ice.createTempClass()
    class NoSuchTopic(Ice.UserException):
        '''This exception indicates that an attempt was made to retrieve a
topic that does not exist.'''
        def __init__(self, name=''):
            self.name = name

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_name = 'IceStorm::NoSuchTopic'

    _M_IceStorm._t_NoSuchTopic = IcePy.defineException('::IceStorm::NoSuchTopic', NoSuchTopic, (), False, None, (('name', (), IcePy._t_string, False, 0),))
    NoSuchTopic._ice_type = _M_IceStorm._t_NoSuchTopic

    _M_IceStorm.NoSuchTopic = NoSuchTopic
    del NoSuchTopic

if 'TopicManager' not in _M_IceStorm.__dict__:
    _M_IceStorm.TopicManager = Ice.createTempClass()
    class TopicManager(Ice.Object):
        '''A topic manager manages topics, and subscribers to topics.'''
        def __init__(self):
            if Ice.getType(self) == _M_IceStorm.TopicManager:
                raise RuntimeError('IceStorm.TopicManager is an abstract class')

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::IceStorm::TopicManager')

        def ice_id(self, current=None):
            return '::IceStorm::TopicManager'

        def ice_staticId():
            return '::IceStorm::TopicManager'
        ice_staticId = staticmethod(ice_staticId)

        def create(self, name, current=None):
            '''Create a new topic. The topic name must be unique, otherwise
TopicExists is raised.

Arguments:
    name The name of the topic.

Returns:
    A proxy to the topic instance.

Exceptions:
    TopicExists Raised if a topic with the same name already
exists.'''
            pass

        def retrieve(self, name, current=None):
            '''Retrieve a topic by name.

Arguments:
    name The name of the topic.

Returns:
    A proxy to the topic instance.

Exceptions:
    NoSuchTopic Raised if the topic does not exist.'''
            pass

        def retrieveAll(self, current=None):
            '''Retrieve all topics managed by this topic manager.

Returns:
    A dictionary of string, topic proxy pairs.'''
            pass

        def getSliceChecksums(self, current=None):
            '''Returns the checksums for the IceStorm Slice definitions.

Returns:
    A dictionary mapping Slice type ids to their checksums.'''
            pass

        def __str__(self):
            return IcePy.stringify(self, _M_IceStorm._t_TopicManager)

        __repr__ = __str__

    _M_IceStorm.TopicManagerPrx = Ice.createTempClass()
    class TopicManagerPrx(Ice.ObjectPrx):

        '''Create a new topic. The topic name must be unique, otherwise
TopicExists is raised.

Arguments:
    name The name of the topic.

Returns:
    A proxy to the topic instance.

Exceptions:
    TopicExists Raised if a topic with the same name already
exists.'''
        def create(self, name, _ctx=None):
            return _M_IceStorm.TopicManager._op_create.invoke(self, ((name, ), _ctx))

        '''Create a new topic. The topic name must be unique, otherwise
TopicExists is raised.

Arguments:
    name The name of the topic.

Returns:
    A proxy to the topic instance.

Exceptions:
    TopicExists Raised if a topic with the same name already
exists.'''
        def begin_create(self, name, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_IceStorm.TopicManager._op_create.begin(self, ((name, ), _response, _ex, _sent, _ctx))

        '''Create a new topic. The topic name must be unique, otherwise
TopicExists is raised.

Arguments:
    name The name of the topic.

Returns:
    A proxy to the topic instance.

Exceptions:
    TopicExists Raised if a topic with the same name already
exists.'''
        def end_create(self, _r):
            return _M_IceStorm.TopicManager._op_create.end(self, _r)

        '''Retrieve a topic by name.

Arguments:
    name The name of the topic.

Returns:
    A proxy to the topic instance.

Exceptions:
    NoSuchTopic Raised if the topic does not exist.'''
        def retrieve(self, name, _ctx=None):
            return _M_IceStorm.TopicManager._op_retrieve.invoke(self, ((name, ), _ctx))

        '''Retrieve a topic by name.

Arguments:
    name The name of the topic.

Returns:
    A proxy to the topic instance.

Exceptions:
    NoSuchTopic Raised if the topic does not exist.'''
        def begin_retrieve(self, name, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_IceStorm.TopicManager._op_retrieve.begin(self, ((name, ), _response, _ex, _sent, _ctx))

        '''Retrieve a topic by name.

Arguments:
    name The name of the topic.

Returns:
    A proxy to the topic instance.

Exceptions:
    NoSuchTopic Raised if the topic does not exist.'''
        def end_retrieve(self, _r):
            return _M_IceStorm.TopicManager._op_retrieve.end(self, _r)

        '''Retrieve all topics managed by this topic manager.

Returns:
    A dictionary of string, topic proxy pairs.'''
        def retrieveAll(self, _ctx=None):
            return _M_IceStorm.TopicManager._op_retrieveAll.invoke(self, ((), _ctx))

        '''Retrieve all topics managed by this topic manager.

Returns:
    A dictionary of string, topic proxy pairs.'''
        def begin_retrieveAll(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_IceStorm.TopicManager._op_retrieveAll.begin(self, ((), _response, _ex, _sent, _ctx))

        '''Retrieve all topics managed by this topic manager.

Returns:
    A dictionary of string, topic proxy pairs.'''
        def end_retrieveAll(self, _r):
            return _M_IceStorm.TopicManager._op_retrieveAll.end(self, _r)

        '''Returns the checksums for the IceStorm Slice definitions.

Returns:
    A dictionary mapping Slice type ids to their checksums.'''
        def getSliceChecksums(self, _ctx=None):
            return _M_IceStorm.TopicManager._op_getSliceChecksums.invoke(self, ((), _ctx))

        '''Returns the checksums for the IceStorm Slice definitions.

Returns:
    A dictionary mapping Slice type ids to their checksums.'''
        def begin_getSliceChecksums(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_IceStorm.TopicManager._op_getSliceChecksums.begin(self, ((), _response, _ex, _sent, _ctx))

        '''Returns the checksums for the IceStorm Slice definitions.

Returns:
    A dictionary mapping Slice type ids to their checksums.'''
        def end_getSliceChecksums(self, _r):
            return _M_IceStorm.TopicManager._op_getSliceChecksums.end(self, _r)

        def checkedCast(proxy, facetOrCtx=None, _ctx=None):
            return _M_IceStorm.TopicManagerPrx.ice_checkedCast(proxy, '::IceStorm::TopicManager', facetOrCtx, _ctx)
        checkedCast = staticmethod(checkedCast)

        def uncheckedCast(proxy, facet=None):
            return _M_IceStorm.TopicManagerPrx.ice_uncheckedCast(proxy, facet)
        uncheckedCast = staticmethod(uncheckedCast)

        def ice_staticId():
            return '::IceStorm::TopicManager'
        ice_staticId = staticmethod(ice_staticId)

    _M_IceStorm._t_TopicManagerPrx = IcePy.defineProxy('::IceStorm::TopicManager', TopicManagerPrx)

    _M_IceStorm._t_TopicManager = IcePy.defineClass('::IceStorm::TopicManager', TopicManager, -1, (), True, False, None, (), ())
    TopicManager._ice_type = _M_IceStorm._t_TopicManager

    TopicManager._op_create = IcePy.Operation('create', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_string, False, 0),), (), ((), _M_IceStorm._t_TopicPrx, False, 0), (_M_IceStorm._t_TopicExists,))
    TopicManager._op_retrieve = IcePy.Operation('retrieve', Ice.OperationMode.Idempotent, Ice.OperationMode.Nonmutating, False, None, (), (((), IcePy._t_string, False, 0),), (), ((), _M_IceStorm._t_TopicPrx, False, 0), (_M_IceStorm._t_NoSuchTopic,))
    TopicManager._op_retrieveAll = IcePy.Operation('retrieveAll', Ice.OperationMode.Idempotent, Ice.OperationMode.Nonmutating, False, None, (), (), (), ((), _M_IceStorm._t_TopicDict, False, 0), ())
    TopicManager._op_getSliceChecksums = IcePy.Operation('getSliceChecksums', Ice.OperationMode.Idempotent, Ice.OperationMode.Nonmutating, False, None, (), (), (), ((), _M_Ice._t_SliceChecksumDict, False, 0), ())

    _M_IceStorm.TopicManager = TopicManager
    del TopicManager

    _M_IceStorm.TopicManagerPrx = TopicManagerPrx
    del TopicManagerPrx

if 'Finder' not in _M_IceStorm.__dict__:
    _M_IceStorm.Finder = Ice.createTempClass()
    class Finder(Ice.Object):
        '''This inferface is advertised by the IceStorm service through the
Ice object with the identity `IceStorm/Finder'. This allows clients
to retrieve the topic manager with just the endpoint information of
the IceStorm service.'''
        def __init__(self):
            if Ice.getType(self) == _M_IceStorm.Finder:
                raise RuntimeError('IceStorm.Finder is an abstract class')

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::IceStorm::Finder')

        def ice_id(self, current=None):
            return '::IceStorm::Finder'

        def ice_staticId():
            return '::IceStorm::Finder'
        ice_staticId = staticmethod(ice_staticId)

        def getTopicManager(self, current=None):
            '''Get the topic manager proxy. The proxy might point to several
replicas.

Returns:
    The topic manager proxy.'''
            pass

        def __str__(self):
            return IcePy.stringify(self, _M_IceStorm._t_Finder)

        __repr__ = __str__

    _M_IceStorm.FinderPrx = Ice.createTempClass()
    class FinderPrx(Ice.ObjectPrx):

        '''Get the topic manager proxy. The proxy might point to several
replicas.

Returns:
    The topic manager proxy.'''
        def getTopicManager(self, _ctx=None):
            return _M_IceStorm.Finder._op_getTopicManager.invoke(self, ((), _ctx))

        '''Get the topic manager proxy. The proxy might point to several
replicas.

Returns:
    The topic manager proxy.'''
        def begin_getTopicManager(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_IceStorm.Finder._op_getTopicManager.begin(self, ((), _response, _ex, _sent, _ctx))

        '''Get the topic manager proxy. The proxy might point to several
replicas.

Returns:
    The topic manager proxy.'''
        def end_getTopicManager(self, _r):
            return _M_IceStorm.Finder._op_getTopicManager.end(self, _r)

        def checkedCast(proxy, facetOrCtx=None, _ctx=None):
            return _M_IceStorm.FinderPrx.ice_checkedCast(proxy, '::IceStorm::Finder', facetOrCtx, _ctx)
        checkedCast = staticmethod(checkedCast)

        def uncheckedCast(proxy, facet=None):
            return _M_IceStorm.FinderPrx.ice_uncheckedCast(proxy, facet)
        uncheckedCast = staticmethod(uncheckedCast)

        def ice_staticId():
            return '::IceStorm::Finder'
        ice_staticId = staticmethod(ice_staticId)

    _M_IceStorm._t_FinderPrx = IcePy.defineProxy('::IceStorm::Finder', FinderPrx)

    _M_IceStorm._t_Finder = IcePy.defineClass('::IceStorm::Finder', Finder, -1, (), True, False, None, (), ())
    Finder._ice_type = _M_IceStorm._t_Finder

    Finder._op_getTopicManager = IcePy.Operation('getTopicManager', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), ((), _M_IceStorm._t_TopicManagerPrx, False, 0), ())

    _M_IceStorm.Finder = Finder
    del Finder

    _M_IceStorm.FinderPrx = FinderPrx
    del FinderPrx

# End of module IceStorm

Ice.sliceChecksums["::IceStorm::AlreadySubscribed"] = "5a82e77b38f02f3118c536f9446a889e"
Ice.sliceChecksums["::IceStorm::BadQoS"] = "44f2de592dd62e3f7f4ffdf043692d"
Ice.sliceChecksums["::IceStorm::Finder"] = "74a058c59ac11fe9a98347ab96533e0"
Ice.sliceChecksums["::IceStorm::InvalidSubscriber"] = "79b17123acba6189e77285da82a862d3"
Ice.sliceChecksums["::IceStorm::LinkExists"] = "e11768febd56a8813729ce69be6c4c2"
Ice.sliceChecksums["::IceStorm::LinkInfo"] = "d0e073e5e0925ec95656f71d572e2e13"
Ice.sliceChecksums["::IceStorm::LinkInfoSeq"] = "a8921e43838692bbe6ca63f3dcf9b6"
Ice.sliceChecksums["::IceStorm::NoSuchLink"] = "fd8f652776796bffca2df1a3baf455a3"
Ice.sliceChecksums["::IceStorm::NoSuchTopic"] = "7a9479a5c39cdd32335d722bbc971176"
Ice.sliceChecksums["::IceStorm::QoS"] = "3e27cb32bc95cca7b013efbf5c254b35"
Ice.sliceChecksums["::IceStorm::Topic"] = "7058388fe7d6c582c2506237904eb7c9"
Ice.sliceChecksums["::IceStorm::TopicDict"] = "fff078a98be068c52d9e1d7d8f6df2a"
Ice.sliceChecksums["::IceStorm::TopicExists"] = "38e6913833539b8d616d114d4e7b28d"
Ice.sliceChecksums["::IceStorm::TopicManager"] = "ffc1baf19222891f8b432be6551fed5"
